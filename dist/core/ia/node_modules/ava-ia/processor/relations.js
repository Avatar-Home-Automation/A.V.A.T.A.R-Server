'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _nlp_compromise = require('compromise');

var _nlp_compromise2 = _interopRequireDefault(_nlp_compromise);

const _ = require('underscore');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// -- Internal
var TERMS_RELATIONS = {
  person: 'subject',
  adverb: 'adverb',
  verb: 'action',
  adjective: 'item',
  noun: 'object',
  date: 'when',
  place: 'location',
  city: 'location',
  value: 'value',
  duration: 'duration'
};

_nlp_compromise2.default.extend(require('compromise-dates'))

exports.default = function (state) {

  var sentence = state.sentence
  var terms = _nlp_compromise2.default(sentence).json()[0].terms
  var relations = {};
  var previous = void 0;
  
  terms.map(function (term) {
	var tag;
	if (_.contains(term.tags, 'Verb')) {
		tag = 'verb'
	} else if ((_.contains(term.tags, 'DateShift') || _.contains(term.tags, 'Value') || _.contains(term.tags, 'Noun') || _.contains(term.tags, 'Preposition') || _.contains(term.tags, 'Duration')) && (_.contains(term.tags, 'NumericValue') || _.contains(term.tags, 'Date') || _.contains(term.tags, 'Unit')) && !_.contains(term.tags, 'Time')) {
		tag = 'duration'
	} else if (	_.contains(term.tags, 'Date') && !_.contains(term.tags, 'Value') && !_.contains(term.tags, "Preposition")) {
		tag = 'date'
	} else if (	_.contains(term.tags, 'Value') && (!_.contains(term.tags, 'Date') || !_.contains(term.tags, 'Unit') || !_.contains(term.tags, 'NumericValue'))) {
		tag = 'value'
	} else if (	_.contains(term.tags, 'Adjective')) {
		tag = 'adjective'
	} else if (	_.contains(term.tags, 'Place') || _.contains(term.tags, 'City')) {
		tag = 'city'
	} else if (	_.contains(term.tags, 'Noun') && !_.contains(term.tags, 'Pronoun')) {
		tag = 'noun'
	} else {
		tag = _.first(term.tags).toLowerCase()
	}
    var relation = void 0;

    if (relation = TERMS_RELATIONS[tag]) {
      if (relation === TERMS_RELATIONS.person && relations[relation]) {
        relation = relations[relation] !== (term.normal || term.text) ? TERMS_RELATIONS.noun : undefined;
      }

      if (relation) {
		  var returnRelation = extractRelation(sentence, tag, term, previous, relations);
		  if (returnRelation && !relations[relation]) {
			  previous = relations[relation] = returnRelation;
		  } else if (returnRelation && relations[relation]) {
			  relations[relation].text = relations[relation].text + ' ' + (term.normal || term.text);
			  previous = relations[relation];
		  } else {
			previous = null;
		  }
	  }
    }
  });
  state.relations = relations;
  return state;
};

// -- Private methods
function extractRelation(sentence, tag, term, previous, relations) {
  var relation = {};
  var flagNot;
  var text = term.normal || term.text;

  switch (tag) {
	case 'duration':
	  if (previous && previous.tag === 'duration' && relations['duration']) {
			relations['duration'].text = relations['duration'].text + ' ' + text
			relations['duration'].tag = tag
			flagNot = true;
	  } 
	  break;
    case 'date':
	  var p_text = _nlp_compromise2.default(sentence).dates().get()[0];
	  if (p_text) {
		  text = _nlp_compromise2.default(p_text.start).dates().format('{month} {date-ordinal} {year}').all().text();
		  relation.info = {
			  start: p_text.start,
			  timezone: p_text.timezone,
			  duration: p_text.duration
		  };
	  }
      break;
    case 'verb':
	  text = _nlp_compromise2.default(text).verbs().toInfinitive().all().text();
      if (!previous) {
		 var negative = _nlp_compromise2.default(sentence).verbs().isNegative().out('array')
		text = negative[0] ? text + ' ' + 'not' : text

        relation.verb = {
          tense: (_.first(term.tags)).toLowerCase().split('tense')[0],
          negative: negative[0] ? true : false
        };
      } else {
		  var keys = Object.keys(previous)
		  if (keys[0] === 'verb') {
			  text = previous.text + ' ' + text
			  relation.verb = previous.verb;
		  }
      }
      break;
	case 'adjective':
		if (previous && previous.tag === 'verb') {
			relations['action'].text = text
			flagNot = true;
		}
		break;
    case 'noun':
		if (previous && previous.tag === 'adjective' && relations['item']) {
			relations['item'].text = relations['item'].text + ' ' + text
			relations['item'].tag = tag
			flagNot = true;
		} else if (relations['object'] && !relations['item']) {
			relations['item'] = { "tag": tag, "text": text }
			flagNot = true;
		} else if (relations['object'] && relations['item']) {
			relations['location'] = { "tag": tag, "text": text }
			flagNot = true;
		}
      break;
  }

  if (!flagNot) {
	  relation.tag = tag;
	  relation.text = text;
	  return relation;
  } else
	  return false;
}
